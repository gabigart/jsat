#!/usr/bin/python

import sys
import subprocess
import re
import os
from optparse import OptionParser
from sys import stderr

tab_size = 4

os_status_desc = {
    'D': "uninterruptible sleep",
    'R': "runnable",
    'S': "interruptible sleep",
    'T': "stopped",
    'Z': "zombie",
}

class StackTrace(object): pass
class ThreadDetails(object): pass

class ThreadStatus(object):
    def __init__(self):
        self.java_status = None
        self.java_status_detail = None
        self.blocked_id = None
        self.blocked_class = None
        self.os_status = None
        self.wchan = None
    def __eq__(self, other):
        if isinstance(other, self.__class__):
            return self.__dict__ == other.__dict__
        else:
            return False
    def __hash__(self): return hash(frozenset(self.__dict__.iteritems()))

def build_stacks(jstack, status_dict):
    res = []
    def add_st(st):
        st.frames = list(reversed(st.frames))
        res.append(st)
    curr = None
    for line in jstack.split('\n'):
        mo_head = re.search(r'^"([^"]+)".*tid=(0x[0-9a-f]+).*nid=(0x[0-9a-f]+)', line)
        mo_frame = re.search(r'^\tat (.+)', line)
        mo_state = re.search(r'java.lang.Thread.State: ([A-Z_]+)(?: \(([^)]+)\))?', line)
        mo_blocked = re.search(r'- [^<>]+<0x([^>]+)> +\(a ([^)]+)\)', line)
        if mo_head is not None:
            if curr is not None: add_st(curr)
            st = StackTrace()
            st.details = ThreadDetails()
            st.details.name = mo_head.group(1)
            st.details.tid = int(mo_head.group(2), 16)
            st.details.nid = int(mo_head.group(3), 16)
            st.frames = []
            st.status = ThreadStatus()
            status = status_dict.get(st.details.nid)
            if status is not None:
                st.status.os_status, st.status.wchan = status
            else:
                print >> stderr, 'WARN: Could not obtain OS status for thread %d' % st.details.nid  
            curr = st
        elif mo_frame is not None:
            curr.frames.append(mo_frame.group(1))
        elif mo_state is not None:
            curr.status.java_status = mo_state.group(1) 
            curr.status.java_status_detail = mo_state.group(2)
        elif mo_blocked is not None:
            if curr.status.java_status in ['WAITING', 'TIMED_WAITING', 'BLOCKED'] and len(curr.frames) == 1:
                curr.status.blocked_id = int(mo_blocked.group(1), 16)
                curr.status.blocked_class = mo_blocked.group(2) 
    if mo_head is not None: add_st(curr)
    return res

def run_command(cmd, args):
    try:
        child = subprocess.Popen([cmd] + args, stdout = subprocess.PIPE, stderr = subprocess.PIPE)
        stdout, stderr = child.communicate()
        if child.returncode != 0:
            raise EnvironmentError(child.returncode, stderr)
    except OSError, e:
        if e.errno == 2: raise EnvironmentError('Cannot execute %s. Is it in the path?' % cmd)
        else: raise
    return stdout

def get_status_dict(pid):
    lwp_list = os.listdir('/proc/%d/task' % pid)
    def wchan_gen():
        for lwp in lwp_list:
            try:
                wchan = open('/proc/%d/task/%s/wchan' % (pid, lwp)).read()
                stat_data = open('/proc/%d/task/%s/stat' % (pid, lwp)).read()
                # Third position is process status
                status = stat_data.split()[2]
                if re.match('[0-9].+', wchan) is not None or wchan == '_stext':
                    # Discarding numeric channels (running processes or old kernels)
                    wchan = None
                yield int(lwp), (status, wchan)
            except IOError, e:
                # Accounting for the fact that a thread can terminate between the moment we
                # ask for the list (directory) and we try to read the file
                if e.errno == 2: print >> stderr, 'WARN: Missing task: %s' % lwp
                else: raise
    return dict(wchan_gen())

def build_frame_tree(st):
    def process_frames(frame_dict, frames, stack):
        if frames:
            process_frames(frame_dict.setdefault(frames[0], {}), frames[1:], stack)
        else:
            frame_dict.setdefault(stack.status, []).append(stack)
    roots = {}
    for stack in st:
        if not stack.frames:
            stack.frames = ['<no stack trace information>']
        process_frames(roots, stack.frames, stack)
    return roots
    
def print_frame_tree(x, indent = 0):
    for a, b in sorted(x.items()):
        if isinstance(a, ThreadStatus):
            status, threads = a, b
            print_thread_status(status, indent)
            for t in threads: print_thread_details(t.details, indent)
            print 
        else:
            frame, children = a, b
            print_frame(frame, indent)
            if len(children) > 1: new_indent = indent + 1
            else: new_indent = indent
            print_frame_tree(children, new_indent)

def print_thread_details(details, indent):
    print '%s"%s" tid=0x%x nid=%d' % (get_indent(indent + 1), details.name, details.tid, details.nid)

def print_thread_status(st, indent):
    detail_str = ''
    if st.java_status_detail is not None:
        detail_str = '(%s)' % st.java_status_detail
    blocked_id_str = ''
    blocked_class_str = ''
    if st.blocked_id is not None:
        blocked_id_str = 'on 0x%x' % st.blocked_id
        blocked_class_str = '(a %s)' % st.blocked_class
    wchan = ''
    if st.wchan is not None:
        wchan = 'in %s()' % st.wchan
    if st.java_status is not None:
        # Skipping native threads
        print '%s+ %s %s %s %s' % (get_indent(indent), st.java_status, detail_str, blocked_id_str, blocked_class_str)
    print '%s+' % get_indent(indent),
    if st.os_status is not None:
        print '%s (%s) %s' % (st.os_status, os_status_desc[st.os_status], wchan)
    else:
        print '<unknown os status>'
    
def print_frame(frame, indent): print '%s- %s' % (' ' * indent * tab_size, frame)

def get_indent(level): return ' ' * (level * tab_size)
    
def error_exit(msg):
    print >> sys.stderr, '%s: %s' % (sys.argv[0], msg)
    sys.exit(1)

def parse_args():
    parser = OptionParser('usage: %prog [options] pid\nPretty print java stack traces')
    options, args = parser.parse_args()
    if len(args) != 1:
        parser.error('A java pid must be supplied')
    pid = int(args[0])
    return pid, options

if __name__ == '__main__':
    pid, options = parse_args()
    try:
        stacks = run_command('jstack', [str(pid)])
        status = get_status_dict(pid)
        roots = build_frame_tree(build_stacks(stacks, status))
        print_frame_tree(roots)
    except EnvironmentError, e:
        error_exit(e)
